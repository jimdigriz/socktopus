#!/usr/bin/env perl

use strict;
use warnings;

use v5.14;

use URI;
use IO::Select;
use IO::Socket::INET;
use Data::GUID;
use Fcntl qw/O_NONBLOCK/;
use POSIX qw/:sys_wait_h/;

require 'sysexits.ph';

use Data::Dumper;

my @uri;
foreach my $a (@ARGV) {
	my $u = URI->new($a);

	unless (defined($u) && $u->scheme ~~ [ 'tcp' ]) {
		print STDERR "'$a' is not a supported URI endpoints\n";
		exit &EX_USAGE;
	}

	push @uri, $u;
}

my %map;

# UDP sockets and *initiating* TCP sockets in here
my $sel_rd = IO::Select->new;
# just TCP sockets in here
my $sel_ex = IO::Select->new;

my $sock = -1;
if (scalar(@uri) > 0) {
	print "running in active mode\n";

	unless (defined($ENV{'UDPLOC'}) 
			&& $ENV{'UDPLOC'} =~ /^(?<sport>[0-9]+):(?<laddr>.*)?:(?<lport>[0-9]+)$/
			&& $+{sport} < 65536 && $+{lport} < 65536) {
		print STDERR "env UDPLOC not set correctly (sport:[laddr]:lport)\n";
		exit &EX_USAGE;
	}

	my $laddr = $+{laddr} || 'localhost';
	my $u = IO::Socket::INET->new(
		LocalPort	=> $+{sport},
		PeerAddr	=> $laddr,
		PeerPort	=> $+{lport},
		Proto		=> 'udp',
	);
	unless (defined($u)) {
		print STDERR "unable to bind() on $+{sport}/udp: $@\n";
		exit &EX_OSERR;
	}

	$map{$u->fileno} = {
		sock	=> $u,
		addr	=> $laddr,
		guid	=> Data::GUID->new->as_string,
		feeds	=> [ ],
		order	=> [ ],
		pids	=> { },
	};

	$sel_rd->add($u);

	unless (defined($ENV{'UDPREM'}) 
			&& $ENV{'UDPREM'} =~ /^(?<dport>[0-9]+):(?<raddr>.*)?:(?<rport>[0-9]+)$/
			&& $+{dport} < 65536 && $+{rport} < 65536) {
		print STDERR "env UDPREM not set correctly (dport:[raddr]:rport)\n";
		exit &EX_USAGE;
	}
	my $dport = $+{dport};
	my $rem = ( $+{raddr} || 'localhost' ) . ":$+{rport}";

	print STDERR "only passing in a single URI, a little strange, but okay...\n"
		unless (scalar(@uri) > 1);

	unless ($uri[0]->scheme eq 'tcp') {
		print STDERR "first URI ('$uri[0]') must be a TCP socket\n";
		exit &EX_USAGE;
	}
} else {
	print "running in passive mode\n";

	my $port = $ENV{'PORT'} || 23461;
	unless ($port =~ /^[0-9]+$/ && $port < 65536) {
		print STDERR "env PORT not set to a suitable TCP port number\n";
		exit &EX_USAGE;
	}

	$sock = IO::Socket::INET->new(
		Listen		=> 5,
		LocalPort	=> $port,
		Proto		=> 'tcp',
		ReuseAddr	=> 1,
	) or die "unable to bind() on $port/tcp: $@\n";

	$sel_rd->add($sock);
}

$SIG{CHLD} = sub {
	local ($!, $?);

	while ((my $pid = waitpid(-1, WNOHANG)) > 0) {
		my $fd;
		foreach my $f (keys %map) {
			next unless (defined($map{$f}{pids}{$pid}));

			$fd = $f;
			last;
		}
		unless (defined($fd)) {
			print STDERR "orphan'd child died...huh?\n";
			next;
		}

		$sel_ex->remove($map{$fd}{pids}{$pid});
		$map{$fd}{pids}{$pid}->close;
		delete $map{$fd}{pids}{$pid};

		unless (scalar(keys %{$map{$fd}{pids}})) {
			$sel_rd->remove($map{$fd}{sock});
			$map{$fd}{sock}->close;
			delete $map{$fd};
		}
	}
};

my $running = 1;
while ($running) {
	my ($r, undef, $e) = IO::Select::select($sel_rd, undef, $sel_ex);

	foreach my $fh (@$e) {
		my $c = recv $fh, undef, 0 ,0;
		print STDERR "socket ${fh->file} exception: $c";

		$sel_rd->remove($fh);
		$sel_ex->remove($fh);

		# TODO
		# kill forks using this socket

		$fh->close;
	}

	foreach my $fh (@$r) {
		if ($fh == $sock) {
			my $c = $fh->accept;
			$sel_rd->add($c);
			$sel_ex->add($c);
			next;
		}

		if (defined($map{$fh->fileno})) {
			&fwd($fh);
			next;
		}

		if ($fh->fileno ~~ [ map { $_->fileno } $sel_ex->handles ]) {
			recv $fh, my $buffer, 10000, 0;
			if (length($buffer) == 0) {
				$sel_rd->remove($fh);
				$sel_ex->remove($fh);
				$fh->close;
				next;
			}

			unless ($buffer =~ /^SOCKTOPUS:0:CONNECT (?<dport>[0-9]+):(?<raddr>.*)?:(?<rport>[0-9]+)(?:[\w]+(?<token>.+))?$/
					&& $+{dport} < 65536 && $+{rport} < 65536) {
				$sel_rd->remove($fh);
				$sel_ex->remove($fh);

				send $fh, "SOCKTOPUS:0:ERROR\n", O_NONBLOCK;
				$fh->close;

				next;
			}

			my $raddr = $+{raddr} || 'localhost';
			my $u = IO::Socket::INET->new(
				LocalPort	=> $+{dport},
				PeerAddr	=> $raddr,
				PeerPort	=> $+{rport},
				Proto		=> 'udp',
			);
			if (defined($u)) {
				$map{$u->fileno} = {
					sock	=> $u,
					addr	=> $raddr,
					guid	=> Data::GUID->new->as_string,
					feeds	=> [ ],
					order	=> [ ],
					pids	=> { },
				};

				$sel_rd->add($u);
			} else {
				foreach my $k (keys %map) {
					next unless ($map{$k}{sock}->sockport == $+{dport}
							&& $map{$k}{addr} eq $raddr
							&& $map{$k}{sock}->peerport == $+{rport});

					unless ($map{$k}{guid} eq $+{token}) {
						send $fh, "SOCKTOPUS:0:ERROR bad token\n", O_NONBLOCK;
						print STDERR "bad token\n";
						last;
					}

					$u = $map{$k};
					last;
				}

				unless (defined($u)) {
					print STDERR "unable to bind $+{rport}/udp: $@\n";
					$sel_rd->remove($fh);
					$sel_ex->remove($fh);
					$fh->close;
					next;
				}
			}

			push @{$map{$u->fileno}{feeds}}, $fh;

			$sel_rd->remove($fh);

			my $pid = fork;
			unless (defined($pid)) {
				print STDERR "unable to fork\n";
				$sel_ex->remove($fh);
				$fh->close;
				next;
			}

			&child($fh, $u)
				if ($pid == 0);

			$map{$u->fileno}{pids}{$pid} = $fh;
		}
	}
}

exit &EX_OK;

sub fwd($) {
	my $fh = shift;
}

sub child($$) {
	my ($tcp, $udp) = @_;

	print $tcp "SOCKTOPUS:0:OK $map{$udp->fileno}{guid}\n";

	my $buffer = '';
	my $length = -1;
	while (1) {
		if ($length == -1) {
			recv $tcp, my $l, 4, 0;
			unless (length($l) == 4) {
				print STDERR "did not read in four bytes\n";
				last;
			}

			$length = unpack 'l>', $l;
			if ($length < 1 || $length > 65535) {
				print STDERR "bad length ('$length')\n";
				last;
			}
		}

		recv $tcp, my $b, $length - length($buffer), 0;
		last if (length($b) == 0);

		$buffer .= $b;
		next if (length($buffer) < $length);

		send $udp, substr($buffer, 0, $length), 0;
		$buffer = substr $buffer, $length;
		$length = -1;
	}

	print STDERR "connection closed\n";

	$tcp->close;

	exit &EX_OK;
}

BEGIN {
	# http://www.perlmonks.org/?node_id=581062
	{
		package NBCSocket;
		use IO::Socket::INET;
		use Errno;
		use Carp;
		our @ISA = 'IO::Socket::INET';
		sub connect {
			@_ == 2 or croak 'usage: $sock->connect(NAME)';
			my $sock = shift;
			my $addr = shift;
			my $timeout = ${*$sock}{'io_socket_timeout'};
			my $err;
			my $blocking;
			$blocking = $sock->blocking(0);
			if (!connect($sock, $addr)) {
				if (!$!{EINPROGRESS}) {
					$err = $!;
					$@ = "connect: $!";
				}
			}
			$! = $err if $err;
			$err ? undef : $sock;
		}
	}
}
