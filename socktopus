#!/usr/bin/env perl

use strict;
use warnings;

use v5.14;

use URI;
use IO::Select;
use IO::Socket::INET;
use Data::GUID;
use Fcntl qw/O_NONBLOCK/;
use POSIX qw/:sys_wait_h/;
use Convert::ASN1 qw/:io/;

require 'sysexits.ph';

use Data::Dumper;

use constant SOCKTOPUS_OID => '2.25.97532385673460346314207847258541901083';

my $data_start = tell DATA;

my @uri;
foreach my $a (@ARGV) {
	my $u = URI->new($a);

	unless (defined($u) && $u->scheme ~~ [ 'tcp' ]) {
		print STDERR "'$a' is not a supported URI endpoints\n";
		exit &EX_USAGE;
	}

	push @uri, $u;
}

my $asn = Convert::ASN1->new;
unless (defined($asn->prepare(\*DATA))) {
	print STDERR "ASN1 bust: ${\$asn->error}\n";
	exit &EX_SOFTWARE;
}
seek DATA, $data_start, 0;

my %oidfwd;
while (<DATA>) {
	next unless /^--\s+socktopus([a-z0-9]+)\s+OBJECT IDENTIFIER\s+::=\s+{\s+socktopus\s+(\d+)\s+}$/i;

	$oidfwd{$1} = SOCKTOPUS_OID . '.' . $2;

	my $h = $asn->find($1);
	unless (defined($h)) {
		print STDERR "'$1' handler not found\n";
		exit &EX_SOFTWARE;
	}

	$asn->registeroid($oidfwd{$1}, $h);
}
my %oidrev = reverse %oidfwd;

my $msg = $asn->find('Message');
unless (defined($msg)) {
	print STDERR "'Message' handler not found\n";
	exit &EX_SOFTWARE;
}

my %map;
my $sel = IO::Select->new;

my $sock = -1;
if (scalar(@uri) > 0) {
	print "running in active mode\n";

	unless (defined($ENV{'UDPLOC'}) 
			&& $ENV{'UDPLOC'} =~ /^(?<sport>[0-9]+):(?<laddr>.*)?:(?<lport>[0-9]+)$/
			&& $+{sport} < 65536 && $+{lport} < 65536) {
		print STDERR "env UDPLOC not set correctly (sport:[laddr]:lport)\n";
		exit &EX_USAGE;
	}

	my $laddr = $+{laddr} || 'localhost';
	my $u = IO::Socket::INET->new(
		LocalPort	=> $+{sport},
		PeerAddr	=> $laddr,
		PeerPort	=> $+{lport},
		Proto		=> 'udp',
	);
	unless (defined($u)) {
		print STDERR "unable to bind() on $+{sport}/udp: $@\n";
		exit &EX_OSERR;
	}

	$map{$u->fileno} = {
		sock	=> $u,
		addr	=> $laddr,
		token	=> Data::GUID->new->as_string,
		feeds	=> [ ],
		order	=> [ ],
		pids	=> { },
	};

	$sel->add($u);

	unless (defined($ENV{'UDPREM'}) 
			&& $ENV{'UDPREM'} =~ /^(?<dport>[0-9]+):(?<raddr>.*)?:(?<rport>[0-9]+)$/
			&& $+{dport} < 65536 && $+{rport} < 65536) {
		print STDERR "env UDPREM not set correctly (dport:[raddr]:rport)\n";
		exit &EX_USAGE;
	}
	my $dport = $+{dport};
	my $rem = ( $+{raddr} || 'localhost' ) . ":$+{rport}";

	print STDERR "only passing in a single URI, a little strange, but okay...\n"
		unless (scalar(@uri) > 1);

	unless ($uri[0]->scheme eq 'tcp') {
		print STDERR "first URI ('$uri[0]') must be a TCP socket\n";
		exit &EX_USAGE;
	}
} else {
	print "running in passive mode\n";

	my $port = $ENV{'PORT'} || 23461;
	unless ($port =~ /^[0-9]+$/ && $port < 65536) {
		print STDERR "env PORT not set to a suitable TCP port number\n";
		exit &EX_USAGE;
	}

	$sock = IO::Socket::INET->new(
		Listen		=> 5,
		LocalPort	=> $port,
		Proto		=> 'tcp',
		ReuseAddr	=> 1,
	) or die "unable to bind() on $port/tcp: $@\n";

	$sel->add($sock);
}

$SIG{CHLD} = sub {
	local ($!, $?);

	while ((my $pid = waitpid(-1, WNOHANG)) > 0) {
		my $fd;
		foreach my $f (keys %map) {
			next unless (defined($map{$f}{pids}{$pid}));

			$fd = $f;
			last;
		}
		unless (defined($fd)) {
			print STDERR "orphan'd child died...huh?\n";
			next;
		}

		my $fh = $map{$fd}{feeds}{$map{$fd}{pids}{$pid}};

		$sel->remove($fh);
		$fh->close;

		delete $map{$fd}{feeds}{$fh->fileno};
		delete $map{$fd}{pids}{$pid};
		@{$map{$fd}{feeds}{order}} = grep { $_ != $fh->fileno } @{$map{$fd}{feeds}{order}};

		unless (scalar(keys %{$map{$fd}{feeds}}) > 0) {
			print STDERR "no longer using $map{$fd}{port}/udp, closing\n";
			$map{$fd}{sock}->close;
			delete $map{$fd};
		}
	}
};

my $running = 1;
while ($running) {
	my ($r, undef, $e) = IO::Select::select($sel, undef, $sel);

	foreach my $fh (@$e) {
		recv $fh, undef, 0 ,0;
		print STDERR "socket ${fh->file} exception: $!";

		$sel->remove($fh);

		$fh->close;
	}

	foreach my $fh (@$r) {
		# new client
		if ($fh == $sock) {
			my $c = $fh->accept;
			$sel->add($c);
			next;
		}

		# new udp packet
		if (defined($map{$fh->fileno})) {
			&egress($fh);
			next;
		}

		# handshaking new stream
		my $message;
		unless (defined(recvmsg($fh, \$message)) && ref $message->{content} eq 'HASH') {
			$sel->remove($fh);
			$fh->close;
			next;
		}

		unless ($message->{type} eq 'Hello') {
			sendmsg($fh, 'Error', tag => '-1', message => 'expected Hello message');

			$sel->remove($fh);
			$fh->close;
			next;
		}

		my $u = IO::Socket::INET->new(
			LocalPort	=> $message->{content}{port},
			PeerAddr	=> $message->{content}{daddress},
			Proto		=> 'udp',
			PeerPort	=> $message->{content}{dport},
		);
		if (defined($u)) {
			if ($u->sockhost eq $u->peerhost && $u->sockport == $u->peerport) {
				print STDERR "loop detected!\n";
				sendmsg($fh, 'Error', tag => '-1', message => 'loop requested');
				$u->close;
				$sel->remove($fh);
				$fh->close;
				next;
			}

			$map{$u->fileno} = {
				sock	=> $u,
				port	=> $message->{content}{port},
				daddr	=> $message->{content}{daddress},
				dport	=> $message->{content}{dport},
				token	=> Data::GUID->new->as_string,
				feeds	=> { },
				pids	=> { },
				order	=> [ ],
			};

			$sel->add($u);
		} else {
			unless (defined($message->{content}{token})) {
				sendmsg($fh, 'Error', tag => '-1', message => 'token required');
				$sel->remove($fh);
				$fh->close;
				next;
			}

			foreach my $k (keys %map) {
				next unless ($message->{content}{port} eq $map{$k}{port}
						&& $message->{content}{daddress} eq $map{$k}{daddr}
						&& $message->{content}{dport} eq $map{$k}{dport});

				unless ($message->{content}{token} eq $map{$k}{token}) {
					print STDERR "bad token\n";
					sendmsg($fh, 'Error', tag => '-1', message => 'bad token');
					last;
				}

				$u = $map{$k}{sock};
				last;
			}

			unless (defined($u)) {
				print STDERR "unable to bind ${\$message->{content}{port}}/udp: $@\n";
				sendmsg($fh, 'Error', tag => '-1', message => 'unable to bind to port');
				$sel->remove($fh);
				$fh->close;
				next;
			}
		}

		my $pid = fork;
		unless (defined($pid)) {
			print STDERR "unable to fork\n";
			sendmsg($fh, 'Error', tag => '-1', message => 'unable to fork');
			$sel->remove($fh);
			$fh->close;
			unless (scalar(keys %{$map{$u->fileno}{feeds}}) > 0) {
				print STDERR "no longer using $map{$u->fileno}{port}/udp, closing\n";
				$u->close;
				delete $map{$u->fileno};
			}
			next;
		}

		if ($pid == 0) {
			STDIN->close;

			$_->close
				foreach (grep { !($_->fileno ~~ [ $fh->fileno, $u->fileno ]) } $sel->handles);

			&ingress($fh, $u);
		}

		$map{$u->fileno}{feeds}{$fh->fileno} = $fh;
		$map{$u->fileno}{pids}{$pid} = $fh->fileno;
		unshift @{$map{$u->fileno}{order}}, $fh->fileno;

		$sel->remove($fh);

		next;
	}
}

exit &EX_OK;

sub ingress {
	my ($tcp, $udp) = @_;

	sendmsg($tcp, 'Connected', tag => '-1', token => $map{$udp->fileno}{token});

	while (1) {
		my $message;
		last unless (defined(recvmsg($tcp, \$message)) && ref $message->{content} eq 'HASH');

		send $udp, $message->{content}{payload}, 0;
	}

	print STDERR "connection closed\n";

	$tcp->close;

	exit &EX_OK;
}

sub egress {
	my $u = shift;

	if (scalar(@uri) > 0) {
	}
}

sub sendmsg {
	my ($sock, $type, %payload) = @_;

	unless (defined($oidfwd{$type})) {
		print STDERR "handler '$type' not found\n";
		exit &EX_SOFTWARE;
	}

	my $m = $msg->encode(type => $oidfwd{$type}, content => \%payload);
	unless (defined($m)) {
		print STDERR "unable to create '$type' Message\n";
		exit &EX_SOFTWARE;
	}

	return asn_send($sock, $m);
}

sub recvmsg {
	my ($sock, $buf) = @_;

	my $sin = asn_recv $sock, my $b, 0;
	return unless (defined($sin));

	my $p = $msg->decode($b);

	my $t = $oidrev{$p->{type}};
	unless (defined($t)) {
		print STDERR "unknown OID '$p->{type}'\n";
		return;
	}

	$p->{type} = $t;

	$$buf = $p;

	return $sin;
}

BEGIN {
	# http://www.perlmonks.org/?node_id=581062
	{
		package NBCSocket;
		use IO::Socket::INET;
		use Errno;
		use Carp;
		our @ISA = 'IO::Socket::INET';
		sub connect {
			@_ == 2 or croak 'usage: $sock->connect(NAME)';
			my $sock = shift;
			my $addr = shift;
			my $timeout = ${*$sock}{'io_socket_timeout'};
			my $err;
			my $blocking;
			$blocking = $sock->blocking(0);
			if (!connect($sock, $addr)) {
				if (!$!{EINPROGRESS}) {
					$err = $!;
					$@ = "connect: $!";
				}
			}
			$! = $err if $err;
			$err ? undef : $sock;
		}
	}
}

__DATA__
-- 49600de0-cfcb-11e4-ad23-0002a5d5c51b
-- socktopus { joint-iso-itu-t(2) uuid(25) socktopus(97532385673460346314207847258541901083) }

Message ::= SEQUENCE {
	type OBJECT IDENTIFIER,
	content ANY DEFINED BY type
}

-- socktopusHello OBJECT IDENTIFIER ::= { socktopus 1 }
Hello ::= SEQUENCE {
	version INTEGER,
	port IA5String,
	daddress IA5String,
	dport IA5String,
	token IA5String OPTIONAL
}

-- socktopusError OBJECT IDENTIFIER ::= { socktopus 2 }
Error ::= SEQUENCE {
	tag INTEGER,
	message PrintableString
}

-- socktopusConnected OBJECT IDENTIFIER ::= { socktopus 3 }
Connected ::= SEQUENCE {
	token IA5String
}

-- socktopusData OBJECT IDENTIFIER ::= { socktopus 4 }
Data ::= SEQUENCE {
	tag INTEGER,
	sequence SEQUENCE {
		global INTEGER,
		local INTEGER
	},
	payload OCTET STRING
}
