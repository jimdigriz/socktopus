#!/usr/bin/env perl

use strict;
use warnings;

use v5.14;

use URI;
use IO::Select;
use IO::Socket::INET;
use Data::GUID;
use Fcntl qw/O_NONBLOCK/;
use POSIX qw/:sys_wait_h/;
use Convert::ASN1 qw/:io/;

require 'sysexits.ph';

use Data::Dumper;

use constant SOCKTOPUS_OID => '2.25.97532385673460346314207847258541901083';

my $data_start = tell DATA;

my $asn = Convert::ASN1->new;
unless (defined($asn->prepare(\*DATA))) {
	warn 'ASN1 bust: ' . $asn->error;
	exit &EX_SOFTWARE;
}
seek DATA, $data_start, 0;

my %oidfwd;
while (<DATA>) {
	next unless /^--\s+socktopus([a-z0-9]+)\s+OBJECT IDENTIFIER\s+::=\s+{\s+socktopus\s+(\d+)\s+}$/i;

	$oidfwd{$1} = SOCKTOPUS_OID . '.' . $2;

	my $h = $asn->find($1);
	unless (defined($h)) {
		warn "'$1' handler not found";
		exit &EX_SOFTWARE;
	}

	$asn->registeroid($oidfwd{$1}, $h);
}
my %oidrev = reverse %oidfwd;

my $msg = $asn->find('Message');
unless (defined($msg)) {
	warn "'Message' handler not found";
	exit &EX_SOFTWARE;
}

my @uri;
foreach my $a (@ARGV) {
	my $u = URI->new($a);

	unless (defined($u) && $u->scheme ~~ [ 'tcp' ]) {
		warn "'$a' is not a supported URI endpoints";
		exit &EX_USAGE;
	}

	push @uri, $u;
}
my $mode = (scalar(@uri)) ? 'active' : 'passive';

my $sock = -1;
my %map;
my $sel_rd = IO::Select->new;
my $sel_wr = IO::Select->new;
my $sel_ex = IO::Select->new;

given ($mode) {
	when ('active') {
		print "running in active mode\n";

		warn 'only passing in a single URI, a little strange, but okay...'
			unless (scalar(@uri) > 1);

		unless ($uri[0]->scheme eq 'tcp') {
			warn "first URI ('$uri[0]') must be a TCP socket";
			exit &EX_USAGE;
		}

		unless (defined($ENV{'UDPLOC'}) 
				&& $ENV{'UDPLOC'} =~ /^(?<sport>[0-9]+):(?<laddr>.*)?:(?<lport>[0-9]+)$/
				&& $+{sport} < 65536 && $+{lport} < 65536) {
			warn 'env UDPLOC not set correctly (sport:[laddr]:lport)';
			exit &EX_USAGE;
		}

		my $laddr = $+{laddr} || 'localhost';
		my $u = IO::Socket::INET->new(
			LocalPort	=> $+{sport},
			PeerAddr	=> $laddr,
			PeerPort	=> $+{lport},
			Proto		=> 'udp',
		);
		unless (defined($u)) {
			warn "unable to bind() on $+{sport}/udp: $@";
			exit &EX_OSERR;
		}

		$map{$u->fileno} = {
			sock	=> $u,
			addr	=> $laddr,
			token	=> Data::GUID->new->as_string,
			feeds	=> [ ],
			order	=> [ ],
			pids	=> { },
		};

		$sel_rd->add($u);

		unless (defined($ENV{'UDPREM'}) 
				&& $ENV{'UDPREM'} =~ /^(?<dport>[0-9]+):(?<raddr>.*)?:(?<rport>[0-9]+)$/
				&& $+{dport} < 65536 && $+{rport} < 65536) {
			warn 'env UDPREM not set correctly (dport:[raddr]:rport)';
			exit &EX_USAGE;
		}
		my $dport = $+{dport};
		my $rem = ( $+{raddr} || 'localhost' ) . ":$+{rport}";
	}
	when ('passive') {
		print "running in passive mode\n";

		my $port = $ENV{'PORT'} || 23461;
		unless ($port =~ /^[0-9]+$/ && $port < 65536) {
			warn 'env PORT not set to a suitable TCP port number';
			exit &EX_USAGE;
		}

		$sock = IO::Socket::INET->new(
			Listen		=> 5,
			LocalPort	=> $port,
			Proto		=> 'tcp',
			ReuseAddr	=> 1,
		) or die "unable to bind() on $port/tcp: $@\n";

		$sel_rd->add($sock);
	}
}

my $running = 1;
$SIG{CHLD} = \&sigchld;

while ($running) {
	my ($r, $w, $e) = IO::Select::select($sel_rd, $sel_wr, $sel_ex);

	foreach my $fh (@$e) {
		recv $fh, undef, 0 ,0;
		warn "socket ${fh->file} exception: $!";

		$sel_rd->remove($fh);
		$sel_ex->remove($fh);

		$fh->close;
	}

	# active
	foreach my $fh (@$w) {
		sendmsg($fh, 'Hello', message => 'expected Hello message');
	}

	foreach my $fh (@$r) {
		# new client
		if ($fh == $sock) {
			my $c = $fh->accept;
			$sel_rd->add($c);
			$sel_ex->add($c);
			next;
		}

		# new udp packet
		if (defined($map{$fh->fileno})) {
			&egress($fh);
			next;
		}

		if ($mode eq 'active') {
			
		}

		# handshaking new stream
		my $message;
		unless (defined(recvmsg($fh, \$message)) && ref $message->{content} eq 'HASH') {
			$sel_rd->remove($fh);
			$sel_ex->remove($fh);
			$fh->close;
			next;
		}

		unless ($message->{type} eq 'Hello') {
			sendmsg($fh, 'Error', message => 'expected Hello message');

			$sel_rd->remove($fh);
			$sel_ex->remove($fh);
			$fh->close;
			next;
		}

		my $u = IO::Socket::INET->new(
			LocalPort	=> $message->{content}{port},
			PeerAddr	=> $message->{content}{daddress},
			Proto		=> 'udp',
			PeerPort	=> $message->{content}{dport},
		);
		if (defined($u)) {
			if ($u->sockhost eq $u->peerhost && $u->sockport == $u->peerport) {
				warn 'loop detected!';
				sendmsg($fh, 'Error', message => 'loop requested');
				$u->close;
				$sel_rd->remove($fh);
				$sel_ex->remove($fh);
				$fh->close;
				next;
			}

			$map{$u->fileno} = {
				sock	=> $u,
				port	=> $message->{content}{port},
				daddr	=> $message->{content}{daddress},
				dport	=> $message->{content}{dport},
				token	=> Data::GUID->new->as_string,
				feeds	=> { },
				pids	=> { },
				order	=> [ ],
			};

			$sel_rd->add($u);
		} else {
			unless (defined($message->{content}{token})) {
				sendmsg($fh, 'Error', message => 'token required');
				$sel_rd->remove($fh);
				$sel_ex->remove($fh);
				$fh->close;
				next;
			}

			foreach my $k (keys %map) {
				next unless ($message->{content}{port} eq $map{$k}{port}
						&& $message->{content}{daddress} eq $map{$k}{daddr}
						&& $message->{content}{dport} eq $map{$k}{dport});

				unless ($message->{content}{token} eq $map{$k}{token}) {
					warn 'bad token';
					sendmsg($fh, 'Error', message => 'bad token');
					last;
				}

				$u = $map{$k}{sock};
				last;
			}

			unless (defined($u)) {
				warn "unable to bind ${\$message->{content}{port}}/udp: $@";
				sendmsg($fh, 'Error', message => 'unable to bind to port');
				$sel_rd->remove($fh);
				$sel_ex->remove($fh);
				$fh->close;
				next;
			}
		}

		my $pid = fork;
		unless (defined($pid)) {
			warn 'unable to fork';
			sendmsg($fh, 'Error', message => 'unable to fork');
			$sel_rd->remove($fh);
			$sel_ex->remove($fh);
			$fh->close;
			unless (scalar(keys %{$map{$u->fileno}{feeds}}) > 0) {
				warn "no longer using \${$map{$u->fileno}{port}}/udp, closing";
				$u->close;
				delete $map{$u->fileno};
			}
			next;
		}

		if ($pid == 0) {
			STDIN->close;

			my @h = $sel_rd->handles;
			push @h, $sel_wr->handles;

			$_->close
				foreach (grep { !($_->fileno ~~ [ $fh->fileno, $u->fileno ]) } @h);

			&ingress($fh, $u);
		}

		$map{$u->fileno}{feeds}{$fh->fileno} = $fh;
		$map{$u->fileno}{pids}{$pid} = $fh->fileno;
		unshift @{$map{$u->fileno}{order}}, $fh->fileno;

		$sel_rd->remove($fh);
		$sel_ex->remove($fh);

		next;
	}
}

exit &EX_OK;

sub sigchld {
	local ($!, $?);

	while ((my $pid = waitpid(-1, WNOHANG)) > 0) {
		my $fd;
		foreach my $f (keys %map) {
			next unless (defined($map{$f}{pids}{$pid}));

			$fd = $f;
			last;
		}
		unless (defined($fd)) {
			warn "orphan'd child died...huh?";
			next;
		}

		my $fh = $map{$fd}{feeds}{$map{$fd}{pids}{$pid}};

		$sel_rd->remove($fh);
		$sel_ex->remove($fh);
		$fh->close;

		delete $map{$fd}{feeds}{$fh->fileno};
		delete $map{$fd}{pids}{$pid};
		@{$map{$fd}{feeds}{order}} = grep { $_ != $fh->fileno } @{$map{$fd}{feeds}{order}};

		unless (scalar(keys %{$map{$fd}{feeds}}) > 0) {
			warn "no longer using \${$map{$fd}{port}}/udp, closing\n";
			$map{$fd}{sock}->close;
			delete $map{$fd};
		}
	}
};

sub ingress {
	my ($tcp, $udp) = @_;

	sendmsg($tcp, 'Connected', token => $map{$udp->fileno}{token});

	while (1) {
		my $message;
		last unless (defined(recvmsg($tcp, \$message)) && ref $message->{content} eq 'HASH');

		send $udp, $message->{content}{payload}, 0;
	}

	warn 'connection closed';

	$tcp->close;

	exit &EX_OK;
}

sub egress {
	my $u = shift;
}

sub sendmsg {
	my ($sock, $type, %payload) = @_;

	unless (defined($oidfwd{$type})) {
		warn "handler '$type' not found";
		exit &EX_SOFTWARE;
	}

	my $m = $msg->encode(type => $oidfwd{$type}, content => \%payload);
	unless (defined($m)) {
		warn "unable to create '$type' Message";
		exit &EX_SOFTWARE;
	}

	return asn_send($sock, $m);
}

sub recvmsg {
	my ($sock, $buf) = @_;

	my $sin = asn_recv $sock, my $b, 0;
	return unless (defined($sin));

	my $p = $msg->decode($b);

	my $t = $oidrev{$p->{type}};
	unless (defined($t)) {
		warn "unknown OID '\${$p->{type}}'";
		return;
	}

	$p->{type} = $t;

	$$buf = $p;

	return $sin;
}

BEGIN {
	# http://www.perlmonks.org/?node_id=581062
	{
		package NBCSocket;
		use IO::Socket::INET;
		use Errno;
		use Carp;
		our @ISA = 'IO::Socket::INET';
		sub connect {
			@_ == 2 or croak 'usage: $sock->connect(NAME)';
			my $sock = shift;
			my $addr = shift;
			my $timeout = ${*$sock}{'io_socket_timeout'};
			my $err;
			my $blocking;
			$blocking = $sock->blocking(0);
			if (!connect($sock, $addr)) {
				if (!$!{EINPROGRESS}) {
					$err = $!;
					$@ = "connect: $!";
				}
			}
			$! = $err if $err;
			$err ? undef : $sock;
		}
	}
}

__DATA__
-- 49600de0-cfcb-11e4-ad23-0002a5d5c51b
-- socktopus { joint-iso-itu-t(2) uuid(25) socktopus(97532385673460346314207847258541901083) }

Message ::= SEQUENCE {
	type OBJECT IDENTIFIER,
	content ANY DEFINED BY type
}

-- socktopusHello OBJECT IDENTIFIER ::= { socktopus 1 }
Hello ::= SEQUENCE {
	version INTEGER,
	port IA5String,
	daddress IA5String,
	dport IA5String,
	token IA5String OPTIONAL
}

-- socktopusError OBJECT IDENTIFIER ::= { socktopus 2 }
Error ::= SEQUENCE {
	message PrintableString
}

-- socktopusConnected OBJECT IDENTIFIER ::= { socktopus 3 }
Connected ::= SEQUENCE {
	token IA5String
}

-- socktopusData OBJECT IDENTIFIER ::= { socktopus 4 }
Data ::= SEQUENCE {
	sequence SEQUENCE {
		global INTEGER,
		local INTEGER
	},
	payload OCTET STRING
}
