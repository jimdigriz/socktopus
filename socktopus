#!/usr/bin/env perl

use strict;
use warnings;

use v5.14;

use URI;
use AnyEvent;
use AnyEvent::Log;
use AnyEvent::Handle;
use AnyEvent::Socket;
use AnyEvent::Handle::UDP;
use IO::Socket::INET;
use Data::GUID;
use Convert::ASN1 qw/:tag/;
use Carp;
use POSIX qw/strftime/;

use Data::Dumper;

use constant SOCKTOPUS_OID	=> '2.25.97532385673460346314207847258541901083';

use constant RE_UDP		=> qr/^(?:\[?(?<host>[^\]]+)\]?:)?(?:(?<serv>[a-z0-9-]+):)?(?:\[?(?<rhost>[^\]]+)\]?:)?(?<rserv>[a-z0-9-]+)$/;
use constant RE_SERVICE		=> qr/^(?:\[?(?<host>[^\]]+)\]?:)?(?<serv>[a-z0-9-]+)$/;

AnyEvent::Log::ctx->fmt_cb(sub { \@_ });
AnyEvent::Log::ctx->log_cb(sub {
	my $m = $AnyEvent::Log::LEVEL2STR[$_[0]->[2]] . ' ' . $_[0]->[3];
	$m = strftime('%F_%T.00000 ', gmtime($_[0]->[0])) . $m
		if (-t STDIN && -t STDOUT);

	if ($_[0]->[2] == 1) {
		Carp::cluck $m;
	} else {
		print STDERR "$m\n";
	}

	1;
});

open my $asn1, '<', 'socktopus.asn1'
	or AE::log fatal => "unable to open: $!";

my $asn = Convert::ASN1->new(tagdefault => 'EXPLICIT');
$asn->prepare($asn1)
	or AE::log fatal => 'ASN1 bust: ' . $asn->error;

seek $asn1, 0, 0;

my %oidfwd;
while (<$asn1>) {
	next unless /^--\s+socktopus([a-zA-Z0-9]+)\s+OBJECT IDENTIFIER\s+::=\s+{\s+socktopus\s+(\d+)\s+}$/;

	$oidfwd{$1} = SOCKTOPUS_OID . '.' . $2;

	my $h = $asn->find($1)
		or AE::log fatal => "'$1' handler not found";

	$asn->registeroid($oidfwd{$1}, $h);
}
my %oidrev = reverse %oidfwd;

close $asn1;

my $msg = $asn->find('Message')
	or AE::log fatal => "'Message' handler not found";

my @uri;
foreach my $a (@ARGV) {
	my $u = URI->new($a);

	AE::log fatal => "'$a' is not a supported URI endpoints"
		unless (defined($u) && $u->scheme ~~ [ 'tcp' ]);

	push @uri, $u;
}
my $mode = (scalar(@uri)) ? 'active' : 'passive';
AE::log info => "running $mode";

my ($sock, %stream, %map);
given ($mode) {
	when ('active') {
		AE::log warn => 'only passing in a single URI'
			unless (scalar(@uri) > 1);

		AE::log fatal => "first URI ('$uri[0]') must be a TCP socket"
			unless ($uri[0]->scheme eq 'tcp');

		AE::log fatal => 'env UDPREM not set correctly ([host:][serv:][rhost:]rserv)'
			unless (defined($ENV{'UDPREM'}) && $ENV{'UDPREM'} =~ RE_UDP);

		AE::log fatal => 'env UDPLOC not set correctly ([host:][serv:][rhost:]rserv)'
			unless (defined($ENV{'UDPLOC'}) && $ENV{'UDPLOC'} =~ RE_UDP);

		my $host = $+{host} || 'localhost';
		my $serv = $+{serv} || '23461';
		my $rhost = $+{rhost} || 'localhost';
		my $fh = IO::Socket::INET->new(
			LocalHost	=> $host,
			PeerHost	=> $rhost,
			Proto		=> 'udp',
			LocalPort	=> $serv,
			PeerPort	=> $+{rserv},
		) or AE::log fatal => "bind: $@";

		my $handle = AnyEvent::Handle::UDP->new(
			fh		=> $fh,
			on_error	=> sub {
				AE::log $_[1] ? 'fatal' : 'error' => $_[2];
			},
			on_recv		=> sub {
				my ($data, $hdl, $src) = @_;
			},
		);

		$map{$fh->fileno} = {
			handle	=> $handle,
			tuple	=> join(' ', $host, $serv, $rhost, $+{rserv}),
			rhost	=> $fh->peerhost,
			rserv	=> $fh->peerport,
			token	=> Data::GUID->new->as_string,
			feed	=> [ ],
			order	=> [ ],
		};

		# disconnect to avoid fatal 'connection refused'
		$fh->connect(pack('S n L x8', AF_UNSPEC, 0, 0));
	}
	when ('passive') {
		my $serv = $ENV{'SERVICE'} || '[::]:23461';
		AE::log fatal => 'env SERVICE not set correctly ([host:]serv)'
			unless ($serv =~ RE_SERVICE);

		$sock = tcp_server($+{host} || '::', $+{serv}, sub {
			my ($fh, $host, $port) = @_;

			my $handle = AnyEvent::Handle->new(fh => $fh);
			$stream{$fh->fileno} = {
				handle	=> $handle,
				state	=> 'new',
			};

			$handle->on_error(sub {
				AE::log $_[1] ? 'fatal' : 'error' => 'stream: ' . $_[2];
				delete $stream{$_[0]->fileno};
			});
			$handle->on_read(sub {
				my ($tb,$tag) = asn_decode_tag($_[0]->{rbuf})
					or return;
				my ($lb,$len) = asn_decode_length(substr($_[0]->{rbuf}, $tb, 8))
					or return;
				return if (length($_[0]->{rbuf}) < $tb + $lb + $len);

				my $m = $msg->decode($_[0]->{rbuf});
				$_[0]->{rbuf} = substr $_[0]->{rbuf}, $tb + $lb + $len;

				recvmsg($_[0], $m);

				1;
			});
			$handle->on_eof(sub {
				AE::log error => 'stream closing';
				$_[0]->push_shutdown;
				delete $stream{$_[0]->fh->fileno};
			});
		});
	}
}

AnyEvent->condvar->recv;

exit 0;

sub sendmsg {
	my ($handle, $type, %payload) = @_;

	AE::log fatal => "handler '$type' not found"
		unless (defined($oidfwd{$type}));

	my $m = $msg->encode(type => $oidfwd{$type}, content => \%payload);
	AE::log fatal => "unable to create '$type' Message"
		unless (defined($m));

	$handle->push_write($m);
}

sub recvmsg {
	my ($handle, $message) = @_;

	AE::log fatal => 'non-decodable message'
		unless (defined($message));

	my $t = $oidrev{$message->{type}};
	unless (defined($t)) {
		AE::log warn => 'unknown OID: ' . $message->{type};
		return;
	}

	given ($stream{$handle->fh->fileno}{state}) {
		when ('new') {
			unless ($t eq 'Hello') {
				AE::log error => "expected Hello message, got $t";
				sendmsg($handle, 'Error', message => 'expected Hello message');
				$handle->push_shutdown;
				break;
			}

			&hookup($handle, $message);

			$stream{$handle->fh->fileno}{state} = 'member';
		}
		when ('member') {
			unless ($t eq 'Data') {
				AE::log error => "expected Data message, got $t";
				sendmsg($handle, 'Error', message => 'expected Data message');
				$handle->push_shutdown;
				break;
			}

			my $ufd = (grep { $handle->fh->fileno ~~ [ @{$map{$_}{feed}} ] } keys %map)[0];
			unless (defined($ufd)) {
				AE::log error => "orphaned fh";
				sendmsg($handle, 'Error', message => 'orphaned fh');
				$handle->push_shutdown;
				break;
			}

			$map{$ufd}{handle}->push_send($message->{content}{payload}, [ $map{$ufd}{rhost}, $map{$ufd}{rserv} ]);
		}
		default {
			AE::log error => "unexpected $t message";
			sendmsg($handle, 'Error', message => "unexpected $t message");
			$handle->push_shutdown;
		}
	}
}

sub hookup {
	my ($handle, $message) = @_;

	my $tuple = join ' ', $message->{content}{host}, $message->{content}{service},
				$message->{content}{rhost}, $message->{content}{rservice};
	my $ufd = (grep { $map{$_}{tuple} eq $tuple } keys %map)[0];
	if (defined($ufd)) {
		unless (defined($message->{content}{token}) && $map{$ufd}{token} eq $message->{content}{token}) {
			AE::log note => 'missing or invalid token';
			sendmsg($handle, 'Error', message => 'requires valid token');
			$handle->push_shutdown;
			return;
		}

		push @{$map{$ufd}{feed}}, $handle->fh->fileno;
	} else {
		my $fh = IO::Socket::INET->new(
			LocalHost	=> $message->{content}{host},
			PeerHost	=> $message->{content}{rhost},
			Proto		=> 'udp',
			LocalPort	=> $message->{content}{service},
			PeerPort	=> $message->{content}{rservice},
		) or AE::log fatal => "bind: $@";

		my $uhandle = AnyEvent::Handle::UDP->new(
			fh		=> $fh,
			on_error	=> sub {
				AE::log $_[1] ? 'fatal' : 'error' => $_[2];
			},
			on_recv		=> sub {
				my ($data, $hdl, $src) = @_;
			},
		);

		$ufd = $fh->fileno;

		$map{$ufd} = {
			handle	=> $uhandle,
			tuple	=> $tuple,
			rhost	=> $fh->peerhost,
			rserv	=> $fh->peerport,
			token	=> Data::GUID->new->as_string,
			feed	=> [ $handle->fh->fileno ],
			order	=> [ ],
		};

		$fh->connect(pack('S n L x8', AF_UNSPEC, 0, 0));
	}

	sendmsg($handle, 'Connected', token => $map{$ufd}{token});
}
