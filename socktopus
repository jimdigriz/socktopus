#!/usr/bin/env perl

use strict;
use warnings;

use v5.14;

use URI;
use IO::Select;
use IO::Socket::INET;
use Data::GUID;

require 'sysexits.ph';

use Data::Dumper;

my @uri;
foreach my $a (@ARGV) {
	my $u = URI->new($a);

	unless (defined($u) && $u->scheme ~~ [ 'tcp' ]) {
		print STDERR "'$a' is not a supported URI endpoints\n";
		exit &EX_USAGE;
	}

	push @uri, $u;
}

my %map;

# UDP sockets and *initiating* TCP sockets in here
my $sel_rd = IO::Select->new;
# just TCP sockets in here
my $sel_ex = IO::Select->new;

my $sock = -1;
if (scalar(@uri) > 0) {
	print "running in active mode\n";

	unless (defined($ENV{'UDPLOC'}) 
			&& $ENV{'UDPLOC'} =~ /^(?<sport>[0-9]+):(?<laddr>.*)?:(?<lport>[0-9]+)$/
			&& $+{sport} < 65536 && $+{lport} < 65536) {
		print STDERR "env UDPLOC not set correctly (sport:[laddr]:lport)\n";
		exit &EX_USAGE;
	}

	unless (defined($ENV{'UDPREM'}) 
			&& $ENV{'UDPREM'} =~ /^(?<dport>[0-9]+):(?<raddr>.*)?:(?<rport>[0-9]+)$/
			&& $+{dport} < 65536 && $+{rport} < 65536) {
		print STDERR "env UDPREM not set correctly (dport:[raddr]:rport)\n";
		exit &EX_USAGE;
	}
	my $dport = $+{dport};
	my $rem = ( $+{raddr} || 'localhost' ) . ":$+{rport}";

	print STDERR "only passing in a single URI, a little strange, but okay...\n"
		unless (scalar(@uri) > 1);

	unless ($uri[0]->scheme eq 'tcp') {
		print STDERR "first URI ('$uri[0]') must be a TCP socket\n";
		exit &EX_USAGE;
	}

	my $raddr = $+{raddr} || 'localhost';
	my $u = IO::Socket::INET->new(
		LocalPort	=> $+{dport},
		PeerAddr	=> $raddr,
		PeerPort	=> $+{rport},
		Proto		=> 'udp',
		Blocking	=> 0,
	) or die "unable to bind() on $+{dport}/udp: $@\n";

	$map{$u->fileno} = { sock => $u, raddr => $raddr, guid => Data::GUID->new->as_string, feeds => [ ], order => [ ] };

	$sel_rd->add($u);
} else {
	print "running in passive mode\n";

	my $port = $ENV{'PORT'} || 23461;
	unless ($port =~ /^[0-9]+$/ && $port < 65536) {
		print STDERR "env PORT not set to a suitable TCP port number\n";
		exit &EX_USAGE;
	}

	$sock = IO::Socket::INET->new(
		Listen		=> 5,
		LocalPort	=> $port,
		Proto		=> 'tcp',
		Blocking	=> 0,
	) or die "unable to bind() on $port/tcp: $@\n";

	$sel_rd->add($sock);
}

my $running = 1;
while ($running) {
	my ($r, undef, $e) = IO::Select::select($sel_rd, undef, $sel_ex);

	foreach my $fh (@$e) {
		my $c = recv $fh, undef, 0 ,0;
		print STDERR "socket ${fh->file} exception: $c";

		$sel_rd->remove($fh);
		$sel_ex->remove($fh);

		# TODO
		# kill forks using this socket

		$fh->close;
	}

	foreach my $fh (@$r) {
		if ($fh == $sock) {
			my $c = $fh->accept;
			$sel_rd->add($c);
			$sel_ex->add($c);
			continue;
		}

		if (defined($map{$fh->fileno})) {
			&fwd($fh);
			continue;
		}

		if ($fh->fileno ~~ [ map { $_->fileno } $sel_ex->handles ]) {
			recv $fh, my $buffer, 10000, 0;
			if (length($buffer) == 0) {
				$sel_rd->remove($fh);
				$sel_ex->remove($fh);
				$fh->close;
				continue;
			}

			unless ($buffer =~ /^SOCKTOPUS:0:CONNECT (?<dport>[0-9]+):(?<raddr>.*)?:(?<rport>[0-9]+)(?:[\w]+(?<token>.+))?$/
					&& $+{dport} < 65536 && $+{rport} < 65536) {
				$sel_rd->remove($fh);
				$sel_ex->remove($fh);

				send $fh, "SOCKTOPUS:0:ERROR\n", 0;
				$fh->close;

				continue;
			}

			my $raddr = $+{raddr} || 'localhost';
			my $u = IO::Socket::INET->new(
				LocalPort	=> $+{dport},
				PeerAddr	=> $raddr,
				PeerPort	=> $+{rport},
				Proto		=> 'udp',
				Blocking	=> 0,
			);
			if (defined($u)) {
				$map{$u->fileno} = { sock => $u, raddr => $raddr, guid => Data::GUID->new->as_string, feeds => [ ], order => [ ] };

				$sel_rd->add($u);
			} else {
				foreach my $k (keys %map) {
					continue unless ($map{$k}{sock}->sockport == $+{dport}
							&& $map{$k}{raddr} eq $+{raddr}
							&& $map{$k}{sock}->peerport == $+{rport});

					unless ($map{$k}{guid} eq $+{token}) {
						print $fh "SOCKTOPUS:0:ERROR bad token\n";
						print STDERR "bad token\n";
						break;
					}

					$u = $map{$k};
					break;
				}

				unless (defined($u)) {
					print STDERR "unable to bind $+{rport}/udp: $@\n";
					$sel_rd->remove($fh);
					$sel_ex->remove($fh);
					$fh->close;
					continue;
				}
			}

			push @{$map{$u->fileno}{feeds}}, $fh;

			$sel_rd->remove($fh);

			print $fh "SOCKTOPUS:0:OK $map{$u->fileno}{guid}\n";

			# FORK
		}
	}
}

exit &EX_OK;

sub fwd($) {
	my $fh = shift;
}

BEGIN {

# http://www.perlmonks.org/?node_id=581062
{
	package NBCSocket;
	use IO::Socket::INET;
	use Errno;
	use Carp;
	our @ISA = 'IO::Socket::INET';
	sub connect {
		@_ == 2 or croak 'usage: $sock->connect(NAME)';
		my $sock = shift;
		my $addr = shift;
		my $timeout = ${*$sock}{'io_socket_timeout'};
		my $err;
		my $blocking;
		$blocking = $sock->blocking(0);
		if (!connect($sock, $addr)) {
			if (!$!{EINPROGRESS}) {
				$err = $!;
				$@ = "connect: $!";
			}
		}
		$! = $err if $err;
		$err ? undef : $sock;
	}
}

}
